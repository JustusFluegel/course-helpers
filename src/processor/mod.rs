use crate::channel_consumer::ChannelConsumer;

pub mod min_max_distance;
pub mod print_best_solutions;

/// Process a solution or collection of solutions (i.e., a population) in some way.
///
/// Implementations of `Processor` are typically used to process the values
/// coming from a channel, such as printing them to the console, computing
/// statistics, or storing them in a database.
///
/// The `process` method is called for each solution or population that
/// is generated by the search process. The `finalize_and_print` method
/// is called after all the solutions have been processed, and is typically
/// used to print any final statistics or other information.
///
/// The default implementation
/// of `ChannelConsumer` for the `Processor` trait will handle the details
/// of consuming values from a channel, so you're not likely to need to
/// implement `ChannelConsumer` explicitly.
///
/// The `Processor` trait is also implemented for tuples of types that
/// implement `Processor`, so you can combine multiple processors into
/// a single processor that will apply all of them to the solutions.
///
/// # Examples
///
/// ## A simple `Processor` implementation
///
/// Here is a simple example of a `Processor` that counts the number of
/// items processed and prints the count at the end:
///
/// ```
/// # use course_helpers::processor::Processor;
/// #
/// #[derive(Default)]
/// struct CountItems {
///    count: usize,
/// }
///
/// impl<S> Processor<S> for CountItems {
///    fn process(&mut self, _solution: &S) {
///        self.count += 1;
///    }
///
///    fn finalize_and_print(&self) {
///        println!("Processed {} items", self.count);
///    }
/// }
///
/// let mut processor = CountItems::default();
/// for value in [58, 96, 32, 77, 101, 44].iter() {
///    processor.process(value);
/// }
///
/// assert_eq!(processor.count, 6);
/// ```
///
/// ## A tuple of processors
///
/// We can also use tuples to gather together two or more processors
/// into a single processor that will apply all of them to the solutions.
///
/// ```
/// # use course_helpers::processor::Processor;
/// # #[derive(Default)]
/// # struct CountItems {
/// #    count: usize,
/// # }
/// #
/// # impl<S> Processor<S> for CountItems {
/// #    fn process(&mut self, _solution: &S) {
/// #        self.count += 1;
/// #    }
/// #
/// #    fn finalize_and_print(&self) {
/// #        println!("Processed {} items", self.count);
/// #    }
/// # }
/// #
/// #[derive(Default)]
/// struct LargestItem {
///     largest: i64,
/// }
///
/// impl Processor<i64> for LargestItem {
///    fn process(&mut self, solution: &i64) {
///        if *solution > self.largest {
///            self.largest = *solution;
///        }
///    }
///
///    fn finalize_and_print(&self) {
///        println!("Largest item: {}", self.largest);
///    }
/// }
///
/// let mut processor = (CountItems::default(), LargestItem::default());
/// for value in [58, 96, 32, 77, 101, 44].iter() {
///     processor.process(value);
/// }
///
/// assert_eq!(processor.0.count, 6);
/// assert_eq!(processor.1.largest, 101);
/// ```
///
/// ## The default implementation of `ChannelConsumer` for `Processor`
///
/// The default implementation of [`ChannelConsumer`] for the `Processor` trait
/// will handle the details of consuming values from a channel, so you're not
/// likely to need to implement [`ChannelConsumer`] explicitly.
///
/// We would typically run the `consume_all` method in a separate thread
/// to process the values coming from the channel, while the main thread
/// continues to generate new values. We would also typically use a bounded
/// channel to avoid running out of memory if the processing thread can't
/// keep up with the generation of new values. Here, though, we're just
/// processing 6 values, so we can use an unbounded channel and do all the
/// processing in the main thread after we've inserted the values into the
/// channel.
///
/// ```
/// # use course_helpers::processor::Processor;
/// # use course_helpers::channel_consumer::ChannelConsumer;
/// #
/// # #[derive(Default)]
/// # struct CountItems {
/// #     count: usize,
/// # }
/// #
/// # impl<S> Processor<S> for CountItems {
/// #     fn process(&mut self, _solution: &S) {
/// #         self.count += 1;
/// #     }
/// #
/// #     fn finalize_and_print(&self) {
/// #         println!("Processed {} items", self.count);
/// #     }
/// # }
/// let mut processor = CountItems::default();
/// let (sender, receiver) = flume::unbounded();
///
/// for value in [58, 96, 32, 77, 101, 44].iter() {
///     sender.send(*value).unwrap();
/// }
///
/// // Dropping the `sender` will close the channel so the receiver
/// // will know when to stop waiting for more values.
/// drop(sender);
///
/// processor.consume_all(receiver);
/// assert_eq!(processor.count, 6);
/// ```
pub trait Processor<S> {
    /// Process a solution, population, or other value
    /// (of type `S`) passed along by the search process.
    fn process(&mut self, solution: &S);

    /// Perform any final processing and generate/print/store any final
    /// summary data about the search process.
    fn finalize_and_print(&self) {}
}

/// A default implementation of `Processor` for tuples of types that
/// implement `Processor`. This allows you to combine multiple processors
/// into a single processor that will apply all of them to the solutions.
impl<S, A, B> Processor<S> for (A, B)
where
    A: Processor<S>,
    B: Processor<S>,
{
    /// The `process` method for a tuple of processors will call the
    /// `process` method for each of the processors in the tuple.
    ///
    /// These are currently done sequentially, so the order of the
    /// processors in the tuple matters, and there's no parallelism
    /// or other concurrency involved.
    fn process(&mut self, solution: &S) {
        self.0.process(solution);
        self.1.process(solution);
    }

    /// The `finalize_and_print` method for a tuple of processors will call
    /// the `finalize_and_print` method for each of the processors in the tuple.
    ///
    /// These are currently done sequentially, so the order of the
    /// processors in the tuple matters, and there's no parallelism
    /// or other concurrency involved.
    fn finalize_and_print(&self) {
        self.0.finalize_and_print();
        self.1.finalize_and_print();
    }
}

impl<S, P> ChannelConsumer<S> for P
where
    P: Processor<S>,
{
    fn consume_all(&mut self, receiver: flume::Receiver<S>) {
        while let Ok(solution) = receiver.recv() {
            self.process(&solution);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Default)]
    struct CountItems {
        count: usize,
    }

    impl<S> Processor<S> for CountItems {
        fn process(&mut self, _solution: &S) {
            self.count += 1;
        }

        fn finalize_and_print(&self) {
            println!("Processed {} items", self.count);
        }
    }

    #[derive(Default)]
    struct LargestItem {
        largest: i64,
    }

    impl Processor<i64> for LargestItem {
        fn process(&mut self, solution: &i64) {
            if *solution > self.largest {
                self.largest = *solution;
            }
        }

        fn finalize_and_print(&self) {
            println!("Largest item: {}", self.largest);
        }
    }

    #[test]
    fn test_processor_tuple() {
        let mut processor = (CountItems::default(), LargestItem::default());

        for value in [58, 96, 32, 77, 101, 44].iter() {
            processor.process(value);
        }

        assert_eq!(processor.0.count, 6);
        assert_eq!(processor.1.largest, 101);
    }

    #[test]
    fn test_processor_channel_consumer() {
        let mut processor = CountItems::default();
        let (sender, receiver) = flume::unbounded();

        for value in [58, 96, 32, 77, 101, 44].iter() {
            sender.send(*value).unwrap();
        }

        drop(sender);

        processor.consume_all(receiver);
        assert_eq!(processor.count, 6);
    }
}
